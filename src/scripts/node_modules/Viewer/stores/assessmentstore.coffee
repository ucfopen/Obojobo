AssessmentUtil = require 'Viewer/util/assessmentutil'
ScoreUtil = require 'Viewer/util/scoreutil'
QuestionUtil = require 'Viewer/util/questionutil'
APIUtil = require 'Viewer/util/apiutil'
NavUtil = require 'Viewer/util/navutil'

Store = window.ObojoboDraft.Common.flux.Store
Dispatcher = window.ObojoboDraft.Common.flux.Dispatcher
OboModel = window.ObojoboDraft.Common.models.OboModel
# ErrorDialog = window.ObojoboDraft.Common.components.modal.ErrorDialog
ErrorUtil = window.ObojoboDraft.Common.util.ErrorUtil

SimpleDialog = window.ObojoboDraft.Common.components.modal.SimpleDialog
ModalUtil = window.ObojoboDraft.Common.util.ModalUtil

getNewAssessmentObject = ->
	current: null
	currentResponses: []
	attempts: []

startAssessmentAttempt = (state, attemptObject) ->
	id = attemptObject.assessmentId
	model = OboModel.models[id]

	model.children.at(1).children.reset()
	for child in attemptObject.state.questions
		c = OboModel.create(child)
		model.children.at(1).children.add c

	if not state.assessments[id]
		state.assessments[id] = getNewAssessmentObject()

	state.assessments[id].current = attemptObject

	NavUtil.rebuildMenu model.getRoot()
	NavUtil.goto id

	model.processTrigger 'onStartAttempt'


class AssessmentStore extends Store
	constructor: ->
		super('assessmentstore')

		Dispatcher.on 'assessment:startAttempt', (payload) =>
			id = payload.value.id
			model = OboModel.models[id]

			APIUtil.startAttempt(model.getRoot(), model, {})
			.then (res) =>
				if res.status is 'error'
					switch res.value.message.toLowerCase()
						when 'attempt limit reached'
							return ErrorUtil.show 'No attempts left', "You have attempted this assessment the maximum number of times available."
						else
							return ErrorUtil.errorResponse res

				startAssessmentAttempt(@state, res.value)
				@triggerChange()

		Dispatcher.on 'assessment:endAttempt', (payload) =>
			id = payload.value.id
			model = OboModel.models[id]

			assessment = @state.assessments[id]

			APIUtil.endAttempt(assessment.current)
			.then (res) =>
				if res.status is 'error' then return ErrorUtil.errorResponse res

				assessment.current.state.questions.forEach (question) ->
					QuestionUtil.hideQuestion question.id

				assessment.currentResponses.forEach (responderId) ->
					QuestionUtil.resetResponse responderId

				assessment.attempts.push res.value
				assessment.current = null

				model.processTrigger 'onEndAttempt'
				@triggerChange()

		Dispatcher.on 'question:recordResponse', (payload) =>
			id = payload.value.id
			model = OboModel.models[id]

			assessment = AssessmentUtil.getAssessmentForModel @state, model
			# if typeof assessment?.current?.responses[id] isnt "undefined"
			# debugger

			if assessment?.currentResponses?
				assessment.currentResponses.push id

			if assessment?.current?
				questionModel = model.getParentOfType('ObojoboDraft.Chunks.Question')

				APIUtil.postEvent(model.getRoot(), 'question:recordResponse', {
					attemptId: assessment.current.attemptId,
					questionId: questionModel.get('id'),
					responderId: id,
					response: payload.value.response
				})
				.then (res) =>
					# APIUtil.recordQuestionResponse assessment.current, questionModel, payload.value.response

					# @triggerChange()
					if res.status is 'error' then return ErrorUtil.errorResponse res
					@triggerChange()

	init: (history = []) ->
		@state = {
			assessments: {}
		}

		history.sort (a, b) ->
			(new Date(a.startTime)).getTime() > (new Date(b.startTime)).getTime()

		unfinishedAttempt = null
		nonExistantQuestions = []

		for attempt in history
			if not @state.assessments[attempt.assessmentId]
				@state.assessments[attempt.assessmentId] = getNewAssessmentObject()

			if not attempt.endTime
				# @state.assessments[attempt.assessmentId].current = attempt
				unfinishedAttempt = attempt
			else
				@state.assessments[attempt.assessmentId].attempts.push attempt

			for question in attempt.state.questions
				if not OboModel.models[question.id]
					nonExistantQuestions.push question

		for question in nonExistantQuestions
			OboModel.create(question)

		if unfinishedAttempt
			ModalUtil.show `<SimpleDialog ok title='Resume Attempt' onConfirm={this.onResumeAttemptConfirm.bind(this, unfinishedAttempt)}><p>It looks like you were in the middle of an attempt. We'll resume you where you left off.</p></SimpleDialog>`
			#startAssessmentAttempt(attempt)

	onResumeAttemptConfirm: (unfinishedAttempt) ->
		ModalUtil.hide()

		startAssessmentAttempt @state, unfinishedAttempt
		@triggerChange()

	getState: -> @state

	setState: (newState) -> @state = newState


assessmentStore = new AssessmentStore()
module.exports = assessmentStore
