Dispatcher = window.ObojoboDraft.Common.flux.Dispatcher

AssessmentUtil =
	getAssessmentForModel: (state, model) ->
		if model.get('type') is 'ObojoboDraft.Sections.Assessment'
			assessmentModel = model
		else
			assessmentModel = model.getParentOfType 'ObojoboDraft.Sections.Assessment'

		if not assessmentModel then return null

		assessment = state.assessments[assessmentModel.get('id')]
		if not assessment then return null

		assessment

	getCurrentAttemptForModel: (state, model) ->
		assessment = AssessmentUtil.getAssessmentForModel state, model
		if not assessment then return null

		assessment.current

	isCurrentAttemptIncomplete: (state, model) ->
		current = AssessmentUtil.getCurrentAttemptForModel state, model
		if not current then return null

		for score in Object.values(current.scores)
			if score is null then return true

		false

	getLastAttemptForModel: (state, model) ->
		assessment = AssessmentUtil.getAssessmentForModel state, model
		if not assessment or assessment.length is 0 then return null

		assessment.attempts[assessment.attempts.length - 1]

	getAttemptAverage: (attempt) ->
		total = 0
		numQuestions = 0

		console.log '@TODO - Maybe instead of checking for Questions look for items that have some sort of "scorable" property?'

		scores = Object.values(attempt.scores)
		finalTotal = scores.reduce (total, score) ->
			total + score

		finalTotal / scores.length

	getLastAttemptAverageForModel: (state, model) ->
		lastAttempt = AssessmentUtil.getLastAttemptForModel(state, model)
		if not lastAttempt then return null

		AssessmentUtil.getAttemptAverage lastAttempt

	getAllAveragesForModel: (state, model) ->
		assessment = AssessmentUtil.getAssessmentForModel state, model
		if assessment is null or assessment.attempts.length is 0 then return null

		scores = []
		for attempt in assessment.attempts
			scores.push AssessmentUtil.getAttemptAverage(attempt)

		scores

	getHighestAssessmentScoreForModel: (state, model) ->
		assessment = AssessmentUtil.getAssessmentForModel state,model
		if assessment is null or assessment.attempts.length is 0 then return null

		AssessmentUtil.getAllAveragesForModel(state, model).reduce (a, b) -> Math.max a, b

	getNumberOfAttempts: (state, model) ->
		assessment = AssessmentUtil.getAssessmentForModel state,model
		if assessment is null or assessment.attempts.length is 0 then return null

		assessment.attempts.length

	getDataForAssessment: (state, model, key) ->
		assessment = AssessmentUtil.getAssessmentForModel state,model
		if not assessment?.current? then return null

		assessment.data[key]

	getDataForCurrentAttempt: (state, model, key) ->
		assessment = AssessmentUtil.getAssessmentForModel state,model
		if not assessment?.current? then return null

		assessment.current.data[key]

	startAttempt: (model) ->
		Dispatcher.trigger 'assessment:startAttempt',
			value:
				id: model.get('id')

	endAttempt: (model) ->
		Dispatcher.trigger 'assessment:endAttempt',
			value:
				id: model.get('id')

	registerQuestionForAttempt: (question) ->
		Dispatcher.trigger 'assessment:registerQuestionForAttempt',
			value:
				id: question.get('id')

	registerDataForAssessment: (model, key, value) ->
		Dispatcher.trigger 'assessment:registerDataForAssessment',
			value:
				id: model.get('id')
				dataKey: key,
				dataValue: value

	registerDataForCurrentAttempt: (model, key, value) ->
		Dispatcher.trigger 'assessment:registerDataForCurrentAttempt',
			value:
				id: model.get('id'),
				dataKey: key,
				dataValue: value


module.exports = AssessmentUtil