require './editorpage.scss'


ObojoboDraft = window.ObojoboDraft
console.log '@TODO List Detector'
#ListDetector = require 'ObojoboDraft/obochunk/list/listdetector'
Keyboard = ObojoboDraft.page.Keyboard
StyleType = ObojoboDraft.text.StyleType
#@TODO:
HTMLToOboNodes = require '../import/html'
ChunkClipboard = require '../history/chunkclipboard'
# insertMenuConfig = require "json!../../../../../insert-menu-config.json"
# SideMenu = require './sidemenu'
Chunk = ObojoboDraft.models.Chunk
DOMUtil = ObojoboDraft.page.DOMUtil
InputHandler = ObojoboDraft.page.InputHandler
ChunkUtil = ObojoboDraft.page.ChunkUtil
ChunkEl = ObojoboDraft.components.Chunk

console.log '@TODO - Use mutation observers to figure out when new content has arrived?' #https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver
console.log '@TODO - Now we have the concept of anchors it would be cool to have selection.start.isAnchor'

EditorPage = React.createClass

	getInitialState: ->
		@chunkClipboard = new ChunkClipboard()
		@inputHandler = new InputHandler()

		#@TODO
		window.__cc = @chunkClipboard

		key: 0

	forcePageRerender: (data) ->
		# console.log 'force rerendar'
		@forcedRerender = data
		@setState { key:@state.key + 1 }

	send: (fn, chunkOrChunks, data) ->
		ChunkUtil.send fn, chunkOrChunks, @props.selection, data

	onKeyDownPutChunkOnClipboard: (event, chunk, afterCallback = ->) ->
		console.log '#############'
		if (event.keyCode is 67 or event.keyCode is 88) and (event.ctrlKey or event.metaKey)
			# alert 'cho'
			@copyHijackCallback = afterCallback
			console.log @copyHijackCallback

			console.log 'yasss'
			@chunkClipboard.store chunk

			hijackEl = @createCopyHijackElement chunk
			document.body.appendChild hijackEl

			hijackEl.focus()
			hijackEl.select()







			return true

		false

	createCopyHijackElement: (chunk) ->
		el = document.createElement 'textarea'
		el.style.position = 'fixed'
		el.style.top = '-9999px'
		el.style.left = '0'
		el.style.zIndex = '999999'
		el.textContent = 'id:' + chunk.get('id')
		el.id = 'obojobo-draft-engine-copy-field'
		el.addEventListener 'keyup', @onCopyHijackElementKeyUp

		el

	onCopyHijackElementKeyUp: (event) ->
		console.clear()
		console.log @copyHijackCallback

		if @copyHijackCallback
			console.log 'YEAH'
			@destroyCopyHijackElement()

			@copyHijackCallback()
			delete @copyHijackCallback

		@props.updateSelectionFn()

	destroyCopyHijackElement: ->
		# return
		el = document.getElementById 'obojobo-draft-engine-copy-field'
		if el?
			el.parentElement.removeChild el

	onEvent: (event) ->
		# return
		# console.log '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>', event.type
		# return

		return if not @props.enabled

		switch event.type
			when 'keydown'     then @onKeyDown     event
			when 'keypress'    then @onKeyPress    event
			when 'keyup'       then @onKeyUp       event
			when 'paste'       then @onPaste       event
			when 'copy'        then @onCopy        event
			when 'cut'         then @onCut         event
			when 'mousedown'   then @onMouseDown   event
			when 'mouseup'     then @onMouseUp     event
			when 'contextmenu' then @onContextMenu event
			when 'input'       then @onInput       event

	onKeyDown: (event) ->
		# if document.activeElement? and document.activeElement.id is 'obojobo-draft-engine-copy-field'
		if @copyHijackCallback then return true

		# return true
		@props.updateSelectionFn()

		# console.clear()

		# switch @props.selection.chunk.type
		# 	when 'caret', 'textSpan'
		# 		console.log @props.selection
		# 		c = @props.selection.chunk.start.chunk.getComponent()

		# 		console.log c.onInsert
		# 		console.log c.inputHandler
		# 		if c.inputHandler?
		# 			console.log c.inputHandler
		# 			c.inputHandler.onKeyDown event, @props.selection, @props.updateFn, @props.updateSelectionFn, @props.styleBrush
		# 			@props.updateFn()
		# 			return

		# 	when 'chunkSpan'
		# 		true

		@inputHandler.onKeyDown event, @props.selection, @props.updateFn, @props.updateSelectionFn, @props.styleBrush

		@props.updateFn()

	# setTextMode: (val) ->
	# 	alert 'idea - setTextMode moves to editor and when off disables controls and any text hijacking, possibly also combine with activateChunk'
	# 	@setState { inTextMode:val }
	# 	@props.setControlsStateFn val #@TODO

	getInputActivityData: ->
		chunk = @props.selection.chunk.start.chunk

		chunk: chunk
		savedDOMState: chunk.saveDOMStateBeforeInput @props.selection
		savedSelection: @props.selection.getSelectionDescriptor()

	onContextMenu: (event) ->
		@props.updateSelectionFn() #@TODO ???

		# chunk = @props.selection.chunk.start.chunk

		@inputActivityData = @getInputActivityData()

	onInput: (event) ->
		if @blockInputEvent?
			delete @blockInputEvent
			return

		# console.log 'INPUT', @forcedRerenderData

		# return true if @activity? and @activity is 'cut'

		if not @inputActivityData?
			@inputActivityData = @getInputActivityData()

		@inputActivityData.domModification = @inputActivityData.chunk.getDOMModificationAfterInput(@props.selection, @inputActivityData.savedDOMState)

		@props.updateSelectionFn() #@TODO?

		@props.selection.setFutureFromDescriptor @inputActivityData.savedSelection #@TODO?

		@inputActivityData.activity = 'input'
		@forcePageRerender @inputActivityData

		delete @inputActivityData

		true

	onKeyPress: (event) ->
		console.log 'EditorPage::onKeyPress', event.charCode
		@props.updateSelectionFn()
		# console.time 'kpCycle'

		event.preventDefault()

		char = String.fromCharCode event.charCode

		@sendText char

	onKeyUp: (event) ->
		@props.updateSelectionFn()
		true

		# if @props.selection?.chunk?.start?.node?
			# console.log 'EditorApp::onKeyUp', @props.selection.chunk.start.chunk.get('index'), ObojoboDraft.components.Text.getOboTextInfo(@props.selection.chunk.start.node)

		# switch event.keyCode
		# 	when Keyboard.LEFT_ARROW, Keyboard.RIGHT_ARROW, Keyboard.UP_ARROW, Keyboard.DOWN_ARROW
		# 		@send 'navigate', @props.selection.chunk.start.chunk, [@prevSel]
		# 		delete @prevSel

	saveSelectionToClipboard: ->
		@chunkClipboard.clear()

		for chunk in @props.selection.chunk.all
			@chunkClipboard.store @send('getCopyOfSelection', chunk)

	onCopy: (event) ->
		@saveSelectionToClipboard()

		true

	onCut: (event) ->
		# console.log 'CUT'

		@blockInputEvent = true

		@props.updateSelectionFn()

		forcedRerenderData =
			selection: @props.selection.getSelectionDescriptor()
			activity: 'cut'

		setTimeout ( ->
			@forcePageRerender forcedRerenderData
		).bind(@)

		true

	onPaste: (event) ->
		event.preventDefault()

		@props.selection.update()

		html = event.clipboardData.getData 'text/html'
		text = event.clipboardData.getData 'text/plain'

		if html.length > 0
			@sendHTML html
			return

		if text.indexOf('id:') is 0
			console.clear()
			chunk = @chunkClipboard.get text.substr(3)
			if chunk?
				chunk.assignNewId()
				console.log chunk
				ChunkUtil.deleteSelection @props.selection
				@send 'splitText', @props.selection.chunk.start.chunk
				splitNode = @props.selection.chunk.start.chunk.nextSibling()
				splitNode.addBefore chunk

				@send 'selectEnd', chunk #@TODO
				# console.log '@TODO - ressurect me ^'

				@props.updateFn()
				return

		@sendText text

	onMouseDown: (event) ->
		@props.selection.clear()
		@props.styleBrush.clean()
		true

	onMouseUp: (event) ->
		console.log 'mouseup', @props.editingChunk
		setTimeout @props.updateSelectionFn.bind(null, @)
		true

	onClick: (event) ->
		# return true
		console.log 'clickum', @props.editingChunk

		clickedChunkIndex = ~~DOMUtil.findParentAttr(event.target, 'data-component-index')
		clickedChunk = @props.module.chunks.at clickedChunkIndex

		if @props.editingChunk isnt null and @props.editingChunk isnt clickedChunk
			# console.log '______'
			@props.stopEditing()
			@props.updateFn()

		# console.clear()
		# console.log @props.selection?.chunk?.start?, @props.editingChunk
		# # @props.updateSelectionFn()
		# if @props.editingChunk isnt null and @props.editingChunk isnt @props.selection.chunk.start.chunk
		# 	console.log 'hay'
		# 	@props.stopEditing()
		# 	return

			# console.log 'EditorApp::onKeyDown', @props.selection.chunk.start.chunk.get('index'), ObojoboDraft.components.Text.getOboTextInfo(@props.selection.chunk.start.node)

	# onClick: (event) ->
	# 	console.log '@TODO - DISABLED CLICK'
	# 	return
	# 	console.log '______onClick', @props.activeChunk
	# 	clickedChunkIndex = ~~DOMUtil.findParentAttr(event.target, 'data-component-index')
	# 	clickedChunk = @props.module.chunks.at clickedChunkIndex

	# 	console.log clickedChunkIndex, clickedChunk
	# 	# @props.selection.clicked = clickedChunk
	# 	@props.selection.update @props.module

	# 	if @props.activeChunk?
	# 		clickedChunkIndex = ~~DOMUtil.findParentAttr(event.target, 'data-component-index')
	# 		clickedChunk = @props.module.chunks.at clickedChunkIndex

	# 		console.log clickedChunkIndex, clickedChunk

	# 		if not clickedChunk? or @props.activeChunk isnt clickedChunk
	# 			console.log '____clearning out activeChunk'
	# 			@setState { activeChunk:null }

	# sendHTML: (html) ->
	# 	console.clear()
	# 	console.log 'sendHTML', @props
	# 	chunks = HTMLToOboNodes html, @props.module

	# 	console.log 'CHUNKS', chunks

	# 	ChunkUtil.deleteSelection @props.selection
	# 	# @send 'splitText', @props.selection.chunk.start.chunk
	# 	splitNode = @props.selection.chunk.start.chunk
	# 	for chunk in chunks
	# 		if chunk?.componentContent?.textGroup?.length is 0 then debugger;
	# 		splitNode.addBefore chunk

	# 	@send 'selectEnd', chunks[chunks.length - 1] #@TODO
	# 	# console.log '@TODO - ressurect me ^'

	# 	@props.updateFn()

	sendHTML: (html) ->
		# console.clear()
		# console.log 'sendHTML', @props
		chunks = HTMLToOboNodes html, @chunkClipboard

		# console.log 'CHUNKS TO PASTE', chunks
		# for chunk in chunks
		# 	if chunk.componentContent.textGroup? and chunk.componentContent.textGroup.length isnt 0
		# 		console.log chunk.id + ':"' + chunk.componentContent.textGroup.get(0).text.value + '"'
		# 	else
		# 		console.log chunk.id + ':<EMPTY>'
		# console.log '------------------'

		ChunkUtil.deleteSelection @props.selection
		@send 'splitText', @props.selection.chunk.start.chunk
		splitNode = @props.selection.chunk.start.chunk.nextSibling()
		for chunk in chunks
			splitNode.addBefore chunk

		@send 'selectEnd', chunks[chunks.length - 1] #@TODO
		# console.log '@TODO - ressurect me ^'

		@props.updateFn()

	sendText: (char) ->
		if @createChunkFromChar(char) then return

		styleBrush = @props.styleBrush

		ChunkUtil.deleteSelection @props.selection
		console.log 'EditorPage::sendText', char, 'to',  @props.selection.chunk.start.chunk
		@send 'insertText', @props.selection.chunk.start.chunk, [char, styleBrush.stylesToApply, styleBrush.stylesToRemove]
		@props.updateFn()

	createChunkFromChar: (char) ->
		# console.log '@TODO'
		# @TODO!!!!
		# if char is ' '
		# 	if @props.selection.chunk.type is 'caret' and @props.selection.chunk.start.chunk.get('type') is 'OboChunk.SingleText' and @send('getCaretEdge', @props.selection.chunk.start.chunk) is 'end'
		# 		group = @props.selection.chunk.start.chunk.componentContent.textGroup
		# 		listDetails = ListDetector group.last.text.value + ' '
		# 		if listDetails isnt false
		# 			group.last.text.init()
		# 			newChunk = Chunk.create 'OboChunk.List'
		# 			listStyles = newChunk.componentContent.listStyles
		# 			listStyles.type = listDetails.type
		# 			listStyles.set 0, { start:listDetails.symbolIndex, bulletStyle:listDetails.symbolStyle }
		# 			@send 'transformSelection', newChunk
		# 			@props.updateFn()
		# 			return true

		if char is '-'
			if @props.selection.chunk.type is 'caret' and @props.selection.chunk.start.chunk.get('type') is 'OboChunk.SingleText' and @send('getCaretEdge', @props.selection.chunk.start.chunk) is 'end'
				group = @props.selection.chunk.start.chunk.componentContent.textGroup
				if group.last.text.value is '--'
					newChunk = Chunk.create 'OboChunk.Break'
					@props.selection.chunk.start.chunk.replaceWith newChunk
					newChunk2 = Chunk.create 'OboChunk.SingleText'
					newChunk.addAfter newChunk2
					@send 'selectStart', newChunk2
					@props.updateFn()
					return true

		false

	# activateChunk: (chunk) ->
	# 	console.log 'ACTIVATE', chunk

	# 	@setState {
	# 		activeChunk: chunk
	# 	}



	selectPageStart: ->
		chunks = @props.module.chunks
		chunks.models[0].selectStart @props.selection

		@props.updateFn()

	selectPageEnd: ->
		chunks = @props.module.chunks
		chunks.models[chunks.length - 1].selectEnd @props.selection

		@props.updateFn()


	# 	module: @props.module
	# 	selection: @props.selection
	# 	styleBrush: @props.styleBrush
	# 	# activeChunk: null
	# 	# inTextMode: true

	# componentWillReceiveProps: (nextProps) ->
	# 	@setState {
	# 		module: nextProps.module
	# 		selection: nextProps.selection
	# 		styleBrush: nextProps.styleBrush
	# 	}

	componentDidMount: ->
		# Disable table resizing in FF
		document.execCommand "enableObjectResizing", false, "false"
		document.execCommand "enableInlineTableEditing", false, "false"

		#DEBUG:
		# document.addEventListener "keydown", ( (event) ->
		# 	if event.keyCode is 49
		# 		event.preventDefault()
		# 		# @setState { inTextMode:!@props.inTextMode }
		# 		chunks = HTMLToOboNodes React.findDOMNode(@).innerHTML
		# 		console.log chunks
		# 		@props.module.chunks.reset chunks
		# 		@props.updateFn()


				# return
		# ).bind(@)



	componentDidUpdate: ->
		# console.clear()
		# console.log '##################################'
		# console.log 'EditorPage::componentDidUpdate', @forcedRerender
		console.timeEnd 'renderPage'



		# Perf.stop()
		# Perf.printWasted()





		if @forcedRerender and @forcedRerender.selection?
			@props.selection.setFutureFromDescriptor @forcedRerender.selection

		futureDesc = @props.selection.getFutureDescriptor()

		console.log 'CDU', futureDesc

		if futureDesc
			# console.log 'YASSSS', futureDesc.start.data.offset, futureDesc.end.data.offset

			@props.selection.selectFromDescriptor @props.module, futureDesc
			@props.selection.clearFuture()

			@props.screen.tweenSelectionIntoViewIfNeeded()
			@props.updateSelectionFn()

		if @forcedRerender?
			switch @forcedRerender.activity
				when 'cut'
					# ChunkUtil.deleteSelection @props.selection
					# @props.module.__print()
					# debugger;
					@saveSelectionToClipboard()
					ChunkUtil.deleteSelection @props.selection

				when 'input'
					@forcedRerender.chunk.applyDOMModification @props.selection, @forcedRerender.domModification


		if @forcedRerender and @forcedRerender.callback?
			@forcedRerender.callback()

		delete @forcedRerender


	render: ->
		console.time 'renderPage'

		# Perf.start()

		saveHistoryFn = @saveHistory
		editChunkFn = @props.editChunk
		stopEditingFn = @props.stopEditing
		window.__activateFn = @activateChunk #@TODO
		showModalFn = @props.showModalFn
		selection = @props.selection
		updateFn = @props.updateFn
		chunkClipboard = @chunkClipboard
		# setTextMode = @setTextMode
		onEvent = @onEvent
		onKeyDownPutChunkOnClipboard = @onKeyDownPutChunkOnClipboard

		updateSelectionFn = @props.updateSelectionFn

		editingChunk = @props.editingChunk
		loading = @props.loading
		module = @props.module
		onSideMenuClick = @onSideMenuClick


		# console.log 'render EditorPage', editingChunk
		console.log '@TODO - Dont like that Im getting the dom selection here when the chunk selection should be up to date theoretically'
		domSel = ObojoboDraft.page.DOMSelection.get()
		curChunkSel = ObojoboDraft.oboDOM.Selection.ChunkSelection.getFromDOMSelection @props.module, domSel


		chunks = `this.props.module.chunks.models.map(function(chunk, index) {
			var Component = chunk.getComponent();
			var chunkSelectionState = curChunkSel ? curChunkSel.getPosition(chunk) : 'none';

			return (<div
				className={'component selection-' + chunkSelectionState + (editingChunk === chunk ? ' editing-chunk' : ' not-editing-chunk')}
				data-component-type={chunk.get('type')}
				data-component-index={index}
				data-oboid={chunk.cid}
				data-id={chunk.get('id')}
				data-server-index={chunk.get('index')}
				data-server-id={chunk.get('id')}
				data-server-derived-from={chunk.get('derivedFrom')}
				data-changed={chunk.dirty}
				data-todo={chunk.get('index') + ':' + chunk.get('id')}
				key={index}
			>
				<Component
					chunk={chunk}
					updateFn={updateFn}
					editChunk={editChunkFn}
					stopEditing={stopEditingFn}
					showModalFn={showModalFn}
					isEditing={editingChunk === chunk}
					selection={selection}
					selectionState={chunkSelectionState}
					updateSelectionFn={updateSelectionFn}
					module={module}
					chunkClipboard={chunkClipboard}
					onKeyDownPutChunkOnClipboard={onKeyDownPutChunkOnClipboard}
					shouldPreventTab={editingChunk !== null && editingChunk !== chunk}
				/>
			</div>);
		});`

		`<div
			className={'editor--components--editor-page' + (editingChunk !== null ? ' editing' : '')}
			key={this.state.key}
			onKeyDown={this.onEvent}
			onKeyPress={this.onEvent}
			onKeyUp={this.onEvent}
			onPaste={this.onEvent}
			onCut={this.onEvent}
			onCopy={this.onEvent}
			onMouseDown={this.onEvent}
			onMouseUp={this.onEvent}
			onContextMenu={this.onEvent}
			onInput={this.onEvent}
			onClick={this.onClick}
			contentEditable={this.props.pageEdit}
			suppressContentEditableWarning={true}
			ref="editor"
		>
			{chunks}
		</div>`



module.exports = EditorPage