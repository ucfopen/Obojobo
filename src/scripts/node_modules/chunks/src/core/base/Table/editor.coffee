require './editor.scss'

CommandHandler = require './commandhandler'
Viewer = require './viewer'

CreateForm = require './createform'
GridTextGroup = require './gridtextgroup'
TableControls = require './table-controls'
GridButton = require './gridbutton'

ObojoboDraft = window.ObojoboDraft
FocusableCommandHandler = ObojoboDraft.command.FocusableCommandHandler
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
TextGroupCursor = ObojoboDraft.text.TextGroupCursor
StyleableText = ObojoboDraft.text.StyleableText
TextGroup = ObojoboDraft.text.TextGroup
Text = ObojoboDraft.components.Text
Chunk = ObojoboDraft.models.Chunk
NonEditableChunk = ObojoboDraft.components.NonEditableChunk
FocusableChunk = ObojoboDraft.components.FocusableChunk
Keyboard = ObojoboDraft.page.Keyboard
ChunkUtil = ObojoboDraft.page.ChunkUtil
EditButton = ObojoboDraft.components.EditButton

textGroupCommandHandler = new CommandHandler()
focusableCommandHandler = new FocusableCommandHandler()

Table = React.createClass
	statics:
		type: 'ObojoboDraft.Chunk.Table'
		register: ->
			OBO.registerChunk Table, {
				insertItem:
					label: 'Table'
					icon: require 'svg-url?noquotes!./assets/insert-icon.svg'
					onInsert: ObojoboDraft.chunk.insertWithText
			}
			OBO.addToolbarItem {
				type: GridButton
				# type: 'button'
				label: 'Table'
				icon: require 'svg-url?noquotes!./assets/toolbar-icon.svg'
				onClick: (toolbarItem, editorState, data) ->
					# ChunkUtil.deleteSelection editorState.selection
					# return

					console.log arguments
					newChunk = Chunk.create Table
					# newChunk.componentContent.textGroup.setDimensions data.rows, data.cols

					ChunkUtil.replaceSelection newChunk, editorState.selection
					newChunk.selectStart editorState.selection
			}
		getCommandHandler: (chunk) ->
			if chunk.editing
				textGroupCommandHandler
			else
				focusableCommandHandler

		# OBONODE DATA METHODS
		# ================================================
		createNewNodeData: ->
			##console.log 'CNND', GridTextGroup.create(3, 3)
			textGroup: GridTextGroup.create(3, 3)
			position: 'center'
			header: true

		cloneNodeData: (data) ->
			textGroup: data.textGroup.clone()
			position: data.position
			header: data.header

		# SERIALIZATION/DECODE METHODS
		# ================================================
		createNodeDataFromDescriptor: (descriptor) ->
			content = descriptor.content

			gridTextGroup: GridTextGroup.fromDescriptor content.gridTextGroup
			position: content.position
			header: content.header

		getDataDescriptor: (chunk) ->
			data = chunk.componentContent

			gridTextGroup: data.textGroup.toDescriptor()
			position: data.position
			header: data.header

		# HTML METHODS
		# ================================================
		createNewNodesFromElement: (el) ->
			null

	getInitialState: ->
		focus:
			row: 0
			col: 0
			offset: 'start'

	addRow: (index = null) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		if not index? then index = data.textGroup.numRows

		data.textGroup.addRow index

		@setState {
			focus:
				row: index
				col: @state.focus.col
				offset: 'start'
		}

	addCol: (index = null) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		if not index? then index = data.textGroup.numCols

		data.textGroup.addCol index

		@setState {
			focus:
				row: @state.focus.row
				col: index
				offset: 'start'
		}

	removeRow: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		if data.textGroup.numRows is 1
			@props.chunk.revert @props.selection
			@props.updateFn()
			return

		data.textGroup.removeRow index

		if @state.focus.row >= index
			@setState {
				focus:
					row: Math.min(index, data.textGroup.numRows - 1)
					col: @state.focus.col
					offset: 'end'
			}

	removeCol: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		if data.textGroup.numCols is 1
			@props.chunk.revert @props.selection
			@props.updateFn()
			return

		data.textGroup.removeCol index

		if @state.focus.col >= index
			@setState {
				focus:
					row: @state.focus.row
					col: Math.min(index, data.textGroup.numCols - 1)
					offset: 'end'
			}

	updateControls: (event) ->
		@props.updateSelectionFn()

		sel = new TextGroupSelection @props.chunk, @props.selection

		if sel.type is 'caret'
			groupIndex = sel.start.groupIndex

			@props.chunk.markForUpdate()
			@props.updateFn()

	onKeyDown2: (newFocus) ->
		if @props.chunk.componentContent.textGroup.getIndexForCellPosition(newFocus) isnt -1
			@setState { focus: newFocus }
			@props.chunk.markForUpdate()
			return true

		false

	onKeyDown: (event) ->
		arrowKeyPressed = false

		sel = new TextGroupSelection @props.chunk, @props.selection
		return true if sel.type isnt 'caret'

		switch event.keyCode
			when Keyboard.UP_ARROW
				@onKeyDown2 {
					row: @state.focus.row - 1
					col: @state.focus.col
					offset: 'end'
				}

				arrowKeyPressed = true

			when Keyboard.DOWN_ARROW
				@onKeyDown2 {
					row: @state.focus.row + 1
					col: @state.focus.col
					offset: 'end'
				}

				arrowKeyPressed = true

			when Keyboard.RIGHT_ARROW
				if sel.start.isTextEnd
					if @state.focus.col is @props.chunk.componentContent.textGroup.numCols - 1
						@onKeyDown2 {
							row: @state.focus.row + 1
							col: 0
							offset: 'start'
						}
					else
						@onKeyDown2 {
							row: @state.focus.row
							col: @state.focus.col + 1
							offset: 'start'
						}

					arrowKeyPressed = true

			when Keyboard.LEFT_ARROW

				if sel.start.isTextStart
					if @state.focus.col is 0
						if @state.focus.row isnt 0
							@onKeyDown2 {
								row: @state.focus.row - 1
								col: @props.chunk.componentContent.textGroup.numCols - 1
								offset: 'end'
							}
					else
						@onKeyDown2 {
							row: @state.focus.row
							col: @state.focus.col - 1
							offset: 'end'
						}

					arrowKeyPressed = true

		if arrowKeyPressed
			event.preventDefault()
			event.stopPropagation()
			return false

		true

	componentWillReceiveProps: (nextProps) ->
		if nextProps.shouldPreventTab isnt @props.shouldPreventTab
			@props.chunk.markForUpdate()

	shouldComponentUpdate: ->
		@props.chunk.needsUpdate

	componentDidUpdate: (prevProps, prevState) ->
		@props.chunk.markUpdated()

		if @props.isEditing and not prevProps.isEditing
			setTimeout (->
				@refs.editTable.focus()
				@updateControls()
			).bind(@)

		# @props.updateSelectionFn()

		setTimeout (->
			@selectCell()
		).bind(@)

	selectCell: ->
		sel = new TextGroupSelection @props.chunk, @props.selection
		chunk = @props.chunk
		data = chunk.componentContent

		# @props.updateSelectionFn()

		if sel.type is 'caret'
			groupIndex = data.textGroup.getIndexForCellPosition @state.focus

			if sel.start.groupIndex isnt groupIndex
				offset = switch @state.focus.offset
					when 'start' then 0
					when 'end' then data.textGroup.get(groupIndex).text.length

				@props.selection.setFutureCaret @props.chunk, { offset:offset, groupIndex:groupIndex }
				desc = @props.selection.getFutureDescriptor()

				@props.selection.selectFromDescriptor @props.module, desc

	onTableMenuCommand: (info) ->
		@refs.editTable.focus()

		switch info.command
			when 'insertColLeft'
				@addCol info.col

			when 'insertColRight'
				@addCol info.col + 1

			when 'insertRowAbove'
				@addRow info.row

			when 'insertRowBelow'
				@addRow info.row + 1

			when 'deleteCol'
				@removeCol info.col

			when 'deleteRow'
				@removeRow info.row

	onEditButtonClick: (event) ->
		event.preventDefault()
		@startEditing()

	onDoubleClick: (event) ->
		if document.elementsFromPoint?
			els = document.elementsFromPoint event.clientX, event.clientY

			for el in els
				if el.getAttribute('data-table-position')?
					attrs = el.getAttribute('data-table-position').split(',')
					if attrs[0] is @props.chunk.get('id')
						return @startEditing ~~attrs[1], ~~attrs[2]

		@startEditing 0, 0

	startEditing: (row = 0, col = 0) ->
		@setFocus row, col, 'end'

		@props.chunk.componentContent.editing = true

		@props.editChunk @props.chunk, { textControlsEnabled:true }

	setFocus: (row, col, offset) ->
		@props.chunk.markForUpdate()

		@setState {
			focus:
				row: row
				col: col
				offset: offset
		}

	onAnchorKeyDown: (event) ->
		if event.keyCode is Keyboard.ENTER
			@startEditing()
			event.preventDefault()
			false

		true

	render: ->
		if @props.isEditing
			@renderTableWithControls()
		else
			@renderPreview()

	renderTableWithControls: ->
		chunk = @props.chunk

		`<NonEditableChunk className="obojobo-draft--chunks--table editor">
			<div className="container editing">
				<TableControls
					selection={this.props.selection}
					chunk={this.props.chunk}
					focus={this.state.focus}
					addRow={this.addRow}
					addCol={this.addCol}
					removeRow={this.removeRow}
					removeCol={this.removeCol}
					onTableMenuCommand={this.onTableMenuCommand}
				/>
				{this.renderEditTable()}
			</div>
		</NonEditableChunk>`

	renderEditTable: ->
		chunk = @props.chunk
		data = chunk.componentContent
		numCols = data.textGroup.numCols
		setFocus = @setFocus



		if data.header
			row = data.textGroup.items.slice(0, numCols).map (textGroupItem, index) ->
				`<th
					key={index}
					className={'cell row-0 col-' + index}
					data-table-position={chunk.get('id') + ',0,' + index}
					onClick={setFocus.bind(null, 0, index, 'end')}
				>
					<Text text={textGroupItem.text} groupIndex={index} />
				</th>`

			header = `<tr key="header">
				{ row }
			</tr>`
		else
			header = null

		startIndex = if data.header then 1 else 0
		rows = [startIndex...data.textGroup.numRows].map (rowNum) ->
			row = data.textGroup.items.slice(rowNum * numCols, (rowNum + 1) * numCols).map (textGroupItem, index) ->
				`<td
					key={index}
					className={'cell row-' + rowNum + ' col-' + index}
					data-table-position={chunk.get('id') + ',' + rowNum + ',' + index}
					onClick={setFocus.bind(null, rowNum, index, 'end')}
				>
					<Text text={textGroupItem.text} groupIndex={rowNum * numCols + index} />
				</td>`

			`<tr key={rowNum}>
				{ row }
			</tr>`


		`<table
			className='edit-table'
			ref="editTable"
			key="editTable"
			contentEditable="true"
			suppressContentEditableWarning={true}
			onClick={this.updateControls}
			onKeyDown={this.onKeyDown}
			onFocus={this.updateControls}
		>
			<thead key="thead">
				{header}
			</thead>
			<tbody key="tbody">
				{rows}
			</tbody>
		</table>`

	renderPreview: ->
		console.log '__TABLE RENDER PREVIEW', @props.shouldPreventTab
		`<FocusableChunk
			className="obojobo-draft--chunks--table preview outline-on-selection"
			onKeyDown={this.onAnchorKeyDown}
			onDoubleClick={this.onDoubleClick}
			shouldPreventTab={this.props.shouldPreventTab}
		>
			<Viewer {...this.props} />
			<EditButton onClick={this.onEditButtonClick} />
		</FocusableChunk>`


module.exports = Table