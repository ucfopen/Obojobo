Editor = window.Editor
Common = window.ObojoboDraft.Common

TextGroupCommandHandler = Editor.chunk.textChunk.TextGroupCommandHandler
FocusableCommandHandler = Editor.chunk.focusableChunk.FocusableCommandHandler

TextGroupSelection = Common.textGroup.TextGroupSelection
Chunk = Common.models.Chunk


# deleteSelection

# _revert = (chunk) ->
# 	console.log 'revert'
# 	newChunk = Chunk.create()
# 	chunk.addChildAfter newChunk
# 	newChunk.absorb chunk
# 	newChunk
# 	# chunk.replaceWith newChunk

_selectionInAnchor = (selection, chunk) ->
	tgs = new TextGroupSelection chunk, selection.virtual
	tgs.start?.groupIndex is 'anchor:main' or tgs.end?.groupIndex is 'anchor:main'

module.exports = class CommandHandler extends TextGroupCommandHandler
	_revert: (chunk) ->
		console.log 'revert'
		newChunk = Chunk.create()
		chunk.addChildAfter newChunk
		newChunk.absorb chunk
		newChunk

	getCaretEdge: (selection, chunk) ->
		return 'start' if _selectionInAnchor(selection, chunk)
		super selection, chunk

	deleteText: (selection, chunk, deleteForwards) ->
		tgs = new TextGroupSelection chunk, selection.virtual
		s = tgs.start

		if s.groupIndex is 'anchor:main'
			chunk = @_revert chunk
			chunk.selectStart()

			if chunk.prevSibling() and not deleteForwards
				chunk.prevSibling().selectEnd()

			return true

		if not deleteForwards and s.isGroupStart
			chunk = @_revert chunk
			chunk.selectStart()
			return true

		if deleteForwards and s.isGroupEnd then return false

		super selection, chunk, deleteForwards

	styleSelection: (selection, chunk, styleType, styleData) ->
		return if _selectionInAnchor(selection, chunk)
		super selection, chunk, styleType, styleData

	unstyleSelection: (selection, chunk, styleType, styleData) ->
		return if _selectionInAnchor(selection, chunk)
		super selection, chunk, styleType, styleData

	getSelectionStyles: (selection, chunk) ->
		return if _selectionInAnchor(selection, chunk)
		super selection, chunk

	onEnter: (selection, chunk, shiftKey) ->
		if _selectionInAnchor(selection, chunk)
			TextGroupSelection.setCaretToTextStart(chunk, 0, selection.virtual)
			chunk.splitText()
			chunk.selectEnd()
			return

		super selection, chunk, shiftKey

	split: (selection, chunk) ->
		if _selectionInAnchor(selection, chunk)
			TextGroupSelection.setCaretToTextStart(chunk, 0, selection.virtual)
			chunk.splitText()
			chunk.selectAll()
			return

		super selection, chunk, shiftKey

	splitText: (selection, chunk, shiftKey) ->
		return if _selectionInAnchor(selection, chunk)

		chunk.markDirty()

		tgs = new TextGroupSelection chunk, selection.virtual

		newText = tgs.start.text.split tgs.start.offset

		newNode = Chunk.create() #@TODO - assumes it has a textGroup
		newNode.modelState.textGroup.first.text = newText
		chunk.addChildAfter newNode

		# selection.setFutureCaret newNode, { offset: 0, groupIndex: 0 }
		# TextGroupSelection.setCaretToGroupStart newNode, selection.virtual
		newNode.selectStart()

	paste: (selection, chunk, text, html, chunks) ->
		if _selectionInAnchor(selection, chunk)
			chunk = @_revert chunk
			pasteIntoChunk = Chunk.create()
			chunk.addChildBefore pasteIntoChunk
			pasteIntoChunk.selectAll()

			return pasteIntoChunk.paste(text, html, chunks)

		@insertText selection, chunk, text

	canMergeWith: (selection, chunk, otherChunk) ->
		super(selection, chunk,otherChunk) and chunk.nextSibling() is otherChunk

	canRemoveSibling: (selection, sibling) -> false

	onSelectAll: (selection, chunk) ->
		TextGroupSelection.selectText chunk, 0, selection.virtual
		true