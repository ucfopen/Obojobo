# Describes a selection in the context of TextGroups for a single chunk

TextGroupCursor = require './textgroupcursor'

VirtualCursor = require 'ObojoboDraft/Common/selection/virtualcursor'
DOMUtil = require 'ObojoboDraft/Common/page/domutil'
emptyChar = require('ObojoboDraft/Common/text/textconstants').EMPTY_CHAR


getCursors = (chunk, virtualSelection) ->
	if not virtualSelection
		return {
			start: null
			end: null
		}

	chunkStart = TextGroupSelection.getGroupStartCursor chunk
	chunkEnd = TextGroupSelection.getGroupEndCursor chunk
	position = virtualSelection.getPosition chunk

	switch position
		when 'start'
			start: new TextGroupCursor virtualSelection.start
			end:   chunkEnd

		when 'end'
			start: chunkStart
			end:   new TextGroupCursor virtualSelection.end

		when 'contains'
			start: new TextGroupCursor virtualSelection.start
			end:   new TextGroupCursor virtualSelection.end

		when 'inside'
			start: chunkStart
			end:   chunkEnd

		else
			start: null
			end: null


class TextGroupSelection
	constructor: (@chunk, @virtualSelection) ->

	# getFrozenSelection: ->
	# 	new TextGroupSelection(chunk, virtualSelection.clone());

	includes: (item) ->
		if @type is 'none' then return false

		groupIndex = item.index
		@start.groupIndex is groupIndex or @end.groupIndex is groupIndex

	selectGroup: ->
		TextGroupSelection.selectGroup @chunk, @virtualSelection

	selectText: (groupIndex) ->
		TextGroupSelection.selectText @chunk, groupIndex, @virtualSelection

	setCaretToGroupStart: ->
		TextGroupSelection.setCaretToGroupStart @chunk, @virtualSelection

	setCaretToTextStart: (groupIndex) ->
		TextGroupSelection.setCaretToTextStart @chunk, groupIndex, @virtualSelection

	setCaretToGroupEnd: ->
		TextGroupSelection.setCaretToGroupEnd @chunk, @virtualSelection

	setCaretToTextEnd: (groupIndex) ->
		TextGroupSelection.setCaretToTextEnd @chunk, groupIndex, @virtualSelection

	setCaret: (groupIndex, offset) ->
		@virtualSelection.setCaret @chunk, { groupIndex:groupIndex, offset:offset }

	setStart: (groupIndex, offset) ->
		@virtualSelection.setStart @chunk, { groupIndex:groupIndex, offset:offset }

	setEnd: (groupIndex, offset) ->
		@virtualSelection.setEnd @chunk, { groupIndex:groupIndex, offset:offset }

	getAllSelectedTexts: ->
		if not @start?.text? or not @end?.text? then return []

		all = []
		for i in [@start.groupIndex..@end.groupIndex]
			all.push @chunk.modelState.textGroup.get(i)

		all


Object.defineProperties(TextGroupSelection.prototype, {
	type:
		get: ->
			cursors = getCursors(@chunk, @virtualSelection)
			position = @position

			switch
				when cursors.start is null or cursors.end is null then 'none'
				when position is 'contains' and cursors.start.groupIndex is cursors.end.groupIndex and cursors.start.offset is cursors.end.offset then 'caret'
				when cursors.start.groupIndex is cursors.end.groupIndex then 'TextSpan'
				else 'multipleTextSpan'

	start: get: -> getCursors(@chunk, @virtualSelection).start
	end: get: -> getCursors(@chunk, @virtualSelection).end
	position: get: -> @virtualSelection.getPosition @chunk
});


TextGroupSelection.getGroupStartCursor = (chunk) ->
	TextGroupSelection.getTextStartCursor chunk, 0

TextGroupSelection.getGroupEndCursor = (chunk) ->
	TextGroupSelection.getTextEndCursor chunk, chunk.modelState.textGroup.length - 1

TextGroupSelection.getTextStartCursor = (chunk, groupIndex) ->
	virtCur = new VirtualCursor chunk, { groupIndex:groupIndex, offset:0 }
	new TextGroupCursor virtCur

TextGroupSelection.getTextEndCursor = (chunk, groupIndex) ->
	virtCur = new VirtualCursor chunk, { groupIndex:groupIndex, offset:chunk.modelState.textGroup.get(groupIndex).text.length }
	new TextGroupCursor virtCur

TextGroupSelection.selectGroup = (chunk, virtualSelection) ->
	start = TextGroupSelection.getGroupStartCursor(chunk)
	end = TextGroupSelection.getGroupEndCursor(chunk)

	virtualSelection.setStart start.virtualCursor.chunk, start.virtualCursor.data
	virtualSelection.setEnd   end.virtualCursor.chunk, end.virtualCursor.data

TextGroupSelection.selectText = (chunk, groupIndex, virtualSelection) ->
	start = TextGroupSelection.getTextStartCursor(chunk, groupIndex)
	end = TextGroupSelection.getTextEndCursor(chunk, groupIndex)

	virtualSelection.setStart start.virtualCursor.chunk, start.virtualCursor.data
	virtualSelection.setEnd   end.virtualCursor.chunk, end.virtualCursor.data

TextGroupSelection.setCaretToGroupStart = (chunk, virtualSelection) ->
	TextGroupSelection.selectGroup chunk, virtualSelection
	virtualSelection.collapse()

TextGroupSelection.setCaretToTextStart = (chunk, groupIndex, virtualSelection) ->
	TextGroupSelection.selectText chunk, groupIndex, virtualSelection
	virtualSelection.collapse()

TextGroupSelection.setCaretToGroupEnd = (chunk, virtualSelection) ->
	TextGroupSelection.selectGroup chunk, virtualSelection
	virtualSelection.collapseToEnd()

TextGroupSelection.setCaretToTextEnd = (chunk, groupIndex, virtualSelection) ->
	TextGroupSelection.selectText chunk, groupIndex, virtualSelection
	virtualSelection.collapseToEnd()

TextGroupSelection.getCursorDataFromDOM = (targetTextNode, offset) ->
	# console.log 'getOboTextInfo', targetTextNode, offset

	totalCharactersFromStart = 0
	# element ?= DOMUtil.getOboElementFromChild targetTextNode.parentElement, 'chunk'

	oboTextNode = DOMUtil.findParentWithAttr targetTextNode, 'data-group-index'


	if oboTextNode
		groupIndexAttr = oboTextNode.getAttribute 'data-group-index'
		groupIndex = parseInt groupIndexAttr, 10
		if isNaN(groupIndex) then groupIndex = groupIndexAttr

	if not oboTextNode? or oboTextNode.textContent is emptyChar
		return {
			offset: 0
			groupIndex: groupIndex
		}

	for textNode in DOMUtil.getTextNodesInOrder(oboTextNode)
		break if textNode is targetTextNode
		totalCharactersFromStart += textNode.nodeValue.length

	anchor = false
	if groupIndexAttr.indexOf('anchor:') is 0
		anchor = groupIndexAttr.substr(groupIndexAttr.indexOf(':') + 1)

	offset += totalCharactersFromStart
	if anchor then offset = 0

	offset: offset
	groupIndex: groupIndex


module.exports = TextGroupSelection