#"obojobo-draft-document-engine": "git+ssh://git@clu.cdl.ucf.edu:obojobo/obojobo-draft-document-engine.git"
OboModel = require './obomodel'

createUUID = require 'ObojoboDraft/Common/util/uuid'

class Chunk extends OboModel
	urlRoot: "/api/chunk"
	sync: (method, model, options) ->
		model.dirty = false
		model.needsUpdate = false

		if method is 'update' or method is 'create'
			options.data = JSON.stringify {chunk: model.toJSON()}
			options.contentType = 'application/json'

		Backbone.sync method, model, options

	# constructor: (attrs) ->
	# 	if not attrs.id?
			# @new = true
			# attrs.id = @createNewLocalId()

		# super attrs

		# @dirty = false
		# @needsUpdate = false
		# @editing = false

		# if attrs.content
		# 	@modelState = @getComponent().createNodeDataFromDescriptor(attrs)
		# else
		# 	@modelState = {}

		# @on "change", @onChange, @

		# @page = null

	url: ->
		if @new? then return @urlRoot
		@urlRoot + '/' + encodeURIComponent(@get('id'))

	save: (attrs, options) ->
		# console.clear()
		console.log 'SAVE TIME'
		if @new?
			@assignNewId()
			options.type = 'post'
			options.success = (->
				if @new then delete @new
				true
			).bind(@)

			console.log options

		super attrs, options

	# assignNewId: ->
	# 	@set 'id', @createNewLocalId()

	# createNewLocalId: ->
	# 	createUUID()

	onChange: (model, options) ->
		if model.get('index') isnt model.previous('index')
			@dirty = true
			@needsUpdate = true

	defaults: ->
		type: 'none'
		content: null
		contentType: 'json'
		derivedFrom: null
		index: null
		draftId: null






	callCommandFn: (fn, content) ->
		componentClass = @getComponent()
		selection = null
		if @page?.module?
			selection = @page.module.app.state.selection
		if not componentClass.getCommandHandler? then return null
		commandHandler = componentClass.getCommandHandler @, selection
		if not commandHandler?[fn] then return null
		commandHandler[fn].apply commandHandler, [selection, @].concat(content)

	callSelectionFn: (fn, content) ->
		componentClass = @getComponent()
		selection = null
		if @page?.module?
			selection = @page.module.app.state.selection
		selectionHandler = @selectionHandler @, selection
		if not selectionHandler?[fn] then return null
		selectionHandler[fn].apply selectionHandler, [selection, @].concat(content)



	# getDomEl: ->
	# 	# @TODO - This work?
	# 	document.body.querySelector ".component[data-id='#{@get('id')}']"
	# 	# document.body.querySelector ".component[data-component-index='#{@get('index')}']"

	# clone: (cloneId = false) ->
	# 	clone = new @constructor {
	# 		type: @get('type')
	# 	}
	# 	clone.modelState = @getComponent().cloneNodeData @modelState

	# 	if cloneId
	# 		clone.set 'id', @get('id')

	# 	clone

	# markDirty: ->
	# 	@dirty = true
	# 	@needsUpdate = true

	# markForUpdate: ->
	# 	@needsUpdate = true

	# markUpdated: ->
	# 	@needsUpdate = false

	isEditing: ->
		@page.module.app.state.editingChunk is @

	# toJSON: ->
	# 	contentJSON = @getComponent().getDataDescriptor @

	# 	json =
	# 		type: @get 'type'
	# 		content: contentJSON
	# 		contentType: @get 'contentType'
	# 		derivedFrom: @get 'derivedFrom'
	# 		index: @get('index')
	# 		id: @get 'id'
	# 		draftId: @get 'draftId'

	# 	json

	# revert: ->
	# 	newChunk = Chunk.create()

	# 	index = @get('index')
	# 	id = @get('id')

	# 	@clear()

	# 	for attrName, attr of newChunk.attributes
	# 		@set attrName, attr

	# 	@set 'index', index
	# 	@set 'id', id

	# 	@modelState = newChunk.modelState

	# 	@

	getCaretEdge: -> @callCommandFn 'getCaretEdge'
	isEmpty: -> @callCommandFn 'isEmpty'
	canRemoveSibling: (sibling) -> @callCommandFn 'canRemoveSibling', [sibling]
	insertText: (textToInsert, stylesToApply, stylesToRemove) -> @callCommandFn 'insertText', [textToInsert, stylesToApply, stylesToRemove]
	deleteText: (deleteForwards) -> @callCommandFn 'deleteText', [deleteForwards]
	onEnter: (shiftKey) -> @callCommandFn 'onEnter', [shiftKey]
	splitText: -> @callCommandFn 'splitText'
	deleteSelection: -> @callCommandFn 'deleteSelection'
	styleSelection: (styleType, styleData) -> @callCommandFn 'styleSelection', [styleType, styleData]
	unstyleSelection: (styleType, styleData) -> @callCommandFn 'unstyleSelection', [styleType, styleData]
	getSelectionStyles: -> @callCommandFn 'getSelectionStyles'
	canMergeWith: (otherChunk) -> @callCommandFn 'canMergeWith', [otherChunk]
	merge: (digestedChunk, mergeText) -> @callCommandFn 'merge', [digestedChunk, mergeText]
	indent: (decreaseIndent) -> @callCommandFn 'indent', [decreaseIndent]
	onTab: (untab) -> @callCommandFn 'onTab', [untab]
	acceptAbsorb: (consumerChunk) -> @callCommandFn 'acceptAbsorb', [consumerChunk]
	absorb: (digestedChunk) -> @callCommandFn 'absorb', [digestedChunk]
	replaceSelection: -> @callCommandFn 'replaceSelection'
	split: -> @callCommandFn 'split'
	getDOMStateBeforeInput: -> @callCommandFn 'getDOMStateBeforeInput'
	getDOMModificationAfterInput: (domStateBefore) -> @callCommandFn 'getDOMModificationAfterInput', [domStateBefore]
	applyDOMModification: (domModifications) -> @callCommandFn 'applyDOMModification', [domModifications]
	onSelectAll: -> @callCommandFn 'onSelectAll'
	getTextMenuCommands: -> @callCommandFn 'getTextMenuCommands'
	paste: (text, html, chunks) -> @callCommandFn 'paste', [text, html, chunks]

	getCopyOfSelection: (cloneId) -> @callSelectionFn 'getCopyOfSelection', [cloneId]
	selectStart: (asRange) -> @callSelectionFn 'selectStart', [asRange]
	selectEnd: (asRange) -> @callSelectionFn 'selectEnd', [asRange]
	selectAll: -> @callSelectionFn 'selectAll'
	getVirtualSelectionStartData: -> @callSelectionFn 'getVirtualSelectionStartData'
	getVirtualSelectionEndData: -> @callSelectionFn 'getVirtualSelectionEndData'
	getDOMSelectionStart: -> @callSelectionFn 'getDOMSelectionStart'
	getDOMSelectionEnd: -> @callSelectionFn 'getDOMSelectionEnd'
	areCursorsEquivalent: (thisCursorData, otherCursorData) -> @callSelectionFn 'areCursorsEquivalent', [thisCursorData, otherCursorData]
	highlightSelection: (comment) -> @callSelectionFn 'highlightSelection', [comment]

Chunk.create = (typeOrClass = null, content = null) ->
	try
		if not typeOrClass?
			componentClass = OBO.componentClassMap.defaultClass
			type = OBO.componentClassMap.getTypeOfClass componentClass
		else if typeof typeOrClass is 'string'
			componentClass = OBO.componentClassMap.getClassForType typeOrClass
			type = typeOrClass
		else
			componentClass = typeOrClass
			type = OBO.componentClassMap.getTypeOfClass typeOrClass

		content ?= componentClass.createNewNodeData()

		chunk = new Chunk {
			type: type
		}
		chunk.modelState = content
	catch e
		throw e
		componentClass = OBO.componentClassMap.errorClass
		chunk = new Chunk(componentClass)
		# type = ComponentClassMap.getTypeOfClass componentClass

	chunk

module.exports = Chunk