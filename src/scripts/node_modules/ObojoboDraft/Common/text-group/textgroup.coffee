StyleableText = require 'ObojoboDraft/Common/text/styleabletext'

Util = require './textgrouputil'
TextGroupItem = require './textgroupitem'

ObjectAssign = require 'object-assign'


getItemsArray = (itemOrItems) ->
	if itemOrItems instanceof TextGroupItem
		[itemOrItems]
	else
		itemOrItems

addChildToGroup = (itemOrItems, group, atIndex = null) ->
	items = getItemsArray itemOrItems

	if atIndex is null
		group.items = group.items.concat items
	else
		group.items = group.items.slice(0, atIndex).concat(items).concat(group.items.slice(atIndex))

	for item in items
		item.parent = group

removeChildFromGroup = (itemOrItems, group) ->
	removedItems = []
	items = getItemsArray itemOrItems

	for item in items
		removed = group.items.splice(item.index, 1)[0]
		removed.parent = null
		removedItems.push removed

	removedItems

setChildToGroup = (item, group, atIndex) ->
	group.items[atIndex] = item
	item.parent = group

removeAllChildrenFromGroup = (group) ->
	for item in group.items
		item.parent = null

	group.items = []

createChild = (text, data, dataTemplate) ->
	new TextGroupItem text, Util.createData(data, dataTemplate)


# dataTemplate defines the data object that will be included in each item in the
# textGroup. Attributes in the data added to the group will be ignored if those
# attributes aren't in the dataTemplate (see Util.createData)
class TextGroup
	constructor: (@maxItems = Infinity, dataTemplate = {}, initialItems = []) ->
		@items = []
		@dataTemplate = Object.freeze ObjectAssign({}, dataTemplate)

		for item in initialItems
			@add item.text, item.data

	clear: ->
		removeAllChildrenFromGroup @

	indexOf: (item) ->
		@items.indexOf(item)

	init: (numItems = 1) ->
		@clear()

		while numItems-- and not @isFull
			@add()

		@

	fill: ->
		return if @maxItems is Infinity

		while not @isFull
			@add()

	add: (text, data) ->
		return @ if @isFull

		addChildToGroup createChild(text, data, @dataTemplate), @

		@

	addAt: (index, text, data) ->
		return @ if @isFull

		addChildToGroup createChild(text, data, @dataTemplate), @, index

		@

	addGroup: (group, cloneDataFn = Util.defaultCloneFn) ->
		@addGroupAt group, null, cloneDataFn

	addGroupAt: (group, index, cloneDataFn = Util.defaultCloneFn) ->
		itemsToAdd = []
		for item in group.items
			clone = item.clone cloneDataFn
			itemsToAdd.push createChild(clone.text, clone.data, @dataTemplate)

		addChildToGroup itemsToAdd, @, index

		@

	get: (index) ->
		@items[index]

	set: (index, text, data) ->
		setChildToGroup createChild(text, data, @dataTemplate), @, index

	remove: (index) ->
		removeChildFromGroup(@items[index], @)[0]

	clone: (cloneDataFn = Util.defaultCloneFn) ->
		clonedItems = []

		for item in @items
			clonedItems.push item.clone(cloneDataFn)

		new TextGroup @maxItems, @dataTemplate, clonedItems

	toDescriptor: ->
		desc = []

		for item in @items
			desc.push { text:item.text.getExportedObject(), data:Util.defaultCloneFn(item.data) }

		desc

	# textGroup.toSlice(0, 1) will reduce your text group to have one item
	toSlice: (from, to = Infinity) ->
		removeChildFromGroup @items.slice(to), @
		removeChildFromGroup @items.slice(0, from), @

		@

	# splits the group into two, one with all the items before the specified index
	# and the other with the items at index and above
	splitBefore: (index) ->
		sibling = new TextGroup @maxItems, @dataTemplate

		while @length isnt index
			item = @remove(index)
			sibling.add item.text, item.data

		sibling

	splitText: (index, offset) ->
		item = @items[index]

		newItem = createChild(item.text.split(offset), Util.defaultCloneFn(item.data), @dataTemplate)

		addChildToGroup newItem, @, index + 1

		newItem

	merge: (index, mergeDataFn = Util.defaultMergeFn) ->
		digestedItem = @items.splice(index + 1, 1)[0]
		consumerItem = @items[index]

		return @ if not digestedItem or not consumerItem

		consumerItem.data = Util.createData(mergeDataFn(consumerItem.data, digestedItem.data), @dataTemplate)

		consumerItem.text.merge digestedItem.text
		@

	deleteSpan: (startIndex, startTextIndex, endIndex, endTextIndex, merge = true, mergeFn = Util.defaultMergeFn) ->
		startItem = @items[startIndex]
		endItem   = @items[endIndex]

		if not startItem then startItem = @first
		if not endItem   then endItem   = @last

		startText = startItem.text
		endText   = endItem.text

		if startText is endText
			startText.deleteText startTextIndex, endTextIndex
			return

		startText.deleteText startTextIndex, startText.length
		endText.deleteText 0, endTextIndex

		if merge
			newItems = []
			for item, i in @items
				if i < startIndex or i > endIndex
					newItems.push item
				else if i is startIndex
					newItems.push startItem
				else if i is endIndex
					newItems.push endItem

			removeAllChildrenFromGroup @
			addChildToGroup newItems, @
			@merge startIndex, mergeFn

	# deletes text but doesn't remove empty texts and doesn't merge any text
	clearSpan: (startIndex, startTextIndex, endIndex, endTextIndex) ->
		startItem = @items[startIndex]
		endItem   = @items[endIndex]
		startText = startItem.text
		endText   = endItem.text

		if startText is endText
			startText.deleteText startTextIndex, endTextIndex
			return

		startText.deleteText startTextIndex, startText.length
		endText.deleteText 0, endTextIndex

		for item, i in @items
			if i > startIndex and i < endIndex
				item.text.init()

		@

	styleText: (startIndex, startTextIndex, endIndex, endTextIndex, styleType, styleData) ->
		@applyStyleFunction 'styleText', arguments

	unstyleText: (startIndex, startTextIndex, endIndex, endTextIndex, styleType, styleData) ->
		@applyStyleFunction 'unstyleText', arguments

	#@TODO - This won't work correctly
	toggleStyleText: (startIndex, startTextIndex, endIndex, endTextIndex, styleType, styleData) ->
		@applyStyleFunction 'toggleStyleText', arguments

	applyStyleFunction: (fn, args) ->
		[startIndex, startTextIndex, endIndex, endTextIndex, styleType, styleData] = args

		# console.log 'APPLY STYLE FUNCTION', startIndex, startTextIndex, endIndex, endTextIndex, styleType, styleData

		startItem = @items[startIndex]
		endItem   = @items[endIndex]
		startText = startItem.text
		endText   = endItem.text

		if startText is endText
			startText[fn] styleType, startTextIndex, endTextIndex, styleData
			return


		foundStartText = false
		for item in @items
			if item.text is startText
				item.text[fn] styleType, startTextIndex, startText.length, styleData
				foundStartText = true
			else if item.text is endText
				item.text[fn] styleType, 0, endTextIndex, styleData
				break
			else if foundStartText
				item.text[fn] styleType, 0, item.text.length, styleData

		@

	getStyles: (startIndex, startTextIndex, endIndex, endTextIndex) ->
		startItem = @items[startIndex]
		endItem   = @items[endIndex]

		if not startItem? or not endItem? then return {}

		startText = startItem.text
		endText   = endItem.text

		if not startText? or not endText? then return {}

		if startText is endText
			return startText.getStyles startTextIndex, endTextIndex

		numTexts = 0
		allStyles = {}
		foundStartText = false
		for item in @items
			styles = {}

			if item.text is startText
				numTexts++
				styles = item.text.getStyles startTextIndex, startText.length
				foundStartText = true
			else if item.text is endText
				numTexts++
				styles = item.text.getStyles 0, endTextIndex
			else if foundStartText
				numTexts++
				styles = item.text.getStyles 0, item.text.length

			for style of styles
				if allStyles[style]?
					allStyles[style]++
				else
					allStyles[style] = 1

			if item.text is endText then break

		returnedStyles = {}
		for style of allStyles
			if allStyles[style] is numTexts
				returnedStyles[style] = style

		returnedStyles


	__debug_print: ->
		console.log '========================'
		for item in @items
			item.text.__debug_print()
			console.log JSON.stringify item.data
			console.log '---------------------'


Object.defineProperties TextGroup.prototype, {
	"length":
		"get": -> @items.length

	"first":
		"get": -> @items[0]

	"last":
		"get": -> @items[@items.length - 1]

	"isFull":
		"get": -> @items.length is @maxItems

	"isEmpty":
		"get": -> @items.length is 0

	"isBlank":
		"get": -> @isEmpty or (@items.length is 1 and @first.text.length is 0)
}

TextGroup.fromDescriptor = (descriptor, maxItems, dataTemplate, restoreDataDescriptorFn = Util.defaultCloneFn) ->
	items = []
	for item in descriptor
		items.push createChild(StyleableText.createFromObject(item.text), restoreDataDescriptorFn(item.data), dataTemplate)

	new TextGroup maxItems, dataTemplate, items

TextGroup.create = (maxItems = Infinity, dataTemplate = {}, numItemsToCreate = 1) ->
	group = new TextGroup maxItems, dataTemplate
	group.init numItemsToCreate

	group





#@TODO
window.TextGroup = TextGroup


module.exports = TextGroup