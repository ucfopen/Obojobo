Metadata = require './metadata'
ChunkCollection = require './chunkcollection'
Chunk = require './chunk'
API = require 'ObojoboDraft/net/api'

class Module extends Backbone.Model
	urlRoot: "/api/module"
	# idAttribute: "shortId"

	constructor: (id = null) ->
		@id = id
		@metadata = new Metadata()
		@chunks = new ChunkCollection()
		# @savedChunks = {}
		@deletedChunks = []

		@chunks.on 'remove', @onChunkRemove, @
		@chunks.on 'add', @onChunkAdd, @
		@chunks.on 'reset', @onChunksReset, @

	onChunkRemove: (model, collection, options) ->
		# @savedChunks[model.get('id')] = model.toJSON()
		@deletedChunks.push model
		@recalcuateIndices()

	onChunkAdd: (model, collection, options) ->
		model.set 'draftId', @id

		@recalcuateIndices()

	onChunksReset: (collection, options) ->
		for chunk in collection.models
			chunk.set 'draftId', @id

		@recalcuateIndices()

	moveChunk: (chunk, newIndex) ->
		@chunks.models.splice(chunk.get('index'), 1)[0]

		@chunks.models.splice newIndex, 0, chunk

		@recalcuateIndices()

		# console.clear()
		API.chunk.move chunk, chunk.prevSibling(), ((event) ->
			# console.clear()
			console.log event

			for chunk in @chunks.models
				console.log chunk.get('id')

			console.log JSON.parse(event.target.responseText)
		).bind(@)

	recalcuateIndices: ->
		for chunk, i in @chunks.models
			chunk.set 'index', i

	toJSON: ->
		metadata: @metadata.toJSON()
		chunks: @chunks.toJSON()

	save: ->
		# console.log('SAVING')

		@saveCount = 0

		for chunk in @chunks.models
			if chunk.dirty
				@saveCount++
				# console.log 'GUNNA SAVE', chunk.componentContent.textGroup

				if chunk.isFirst()
					beforeId = null
				else
					beforeId = chunk.prevSibling().id

				chunk.save({
					before_chunk_id: beforeId
				}, {
					success:@onSaved.bind(@)
				})

		# console.log 'GONNA DELETE', @deletedChunks.length
		while @deletedChunks.length > 0
			console.log @deletedChunks.length
			@deletedChunks.pop().destroy()

		@deletedChunks = []

	onSaved: ->
		# console.log 'ON SAVED!', @saveCount
		@saveCount--
		if @saveCount is 0
			# console.log 'UPA DATAA'
			@update()

	markDirty: ->
		for chunk in @chunks.models
			chunk.markDirty()

	markForUpdate: ->
		for chunk in @chunks.models
			chunk.markForUpdate()

	fromDescriptor: (descriptor) ->
		@clear()

		newModule = Module.createFromDescriptor descriptor

		@metadata = newModule.metadata
		@chunks = newModule.chunks

		@markDirty()

	# saveChunk: (chunk) ->
	# 	@savedChunks[chunk.get('id')] = chunk.toJSON()

	# Includes savedChunks @TODO?
	# getChunkById: (id) ->
	# 	console.log '--get chunk by id', id
	# 	chunk = @chunks.get id
	# 	console.log '----found', chunk
	# 	if not chunk?
	# 		console.log '----dig deeper'
	# 		descriptor = @savedChunks[id]
	# 		if descriptor?
	# 			console.log '----BIRTH'
	# 			console.log descriptor
	# 			chunk = new Chunk(descriptor)
	# 			console.log chunk

	# 	chunk


	__print: ->
		# for chunk in @chunks.models
			# console.log chunk.id + ':' + chunk.componentContent.textGroup.items.length
		console.log 'CHUNKS:'
		for chunk in @chunks.models
			if chunk.componentContent?.textGroup? and chunk.componentContent.textGroup.length isnt 0
				console.log chunk.id + '|' + chunk.get('index') + ':"' + chunk.componentContent.textGroup.get(0).text.value + '"'
			else
				console.log chunk.id + '|' + chunk.get('index') + ':<EMPTY>'



Module.createFromDescriptor = (descriptor) ->
	m = new Module descriptor.id
	# m.metadata = new Metadata descriptor.metadata
	m.metadata = new Metadata()

	chunks = []
	for chunkDescriptor in descriptor.chunks
		# chunks.push Chunk.createFromDescriptor(chunkDescriptor)
		# console.log chunkDescriptor
		try
			chunkDescriptor.draftId = descriptor.id
			console.log 'new chunk', chunkDescriptor
			chunks.push new Chunk(chunkDescriptor)
		catch e
			console.log 'ERROR', e

	if chunks.length is 0
		chunks.push Chunk.create()

	m.chunks.reset chunks

	m



module.exports = Module