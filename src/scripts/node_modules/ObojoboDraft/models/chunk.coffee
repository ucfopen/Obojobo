#"obojobo-draft-document-engine": "git+ssh://git@clu.cdl.ucf.edu:obojobo/obojobo-draft-document-engine.git"

ComponentClassMap = require 'ObojoboDraft/util/componentclassmap'
createUUID = require 'ObojoboDraft/util/uuid'

class Chunk extends Backbone.Model
	urlRoot: "/api/chunk"
	sync: (method, model, options) ->
		# console.log 'SYNC', arguments, model.componentContent.textGroup

	# 	if method is 'read'
	# 		options.url = model.url()
	# 	else
	# 		options.url = model.urlRoot

		######## @set 'savedJSON', JSON.stringify(@toJSON())

		#@TODO - assumes success!
		model.dirty = false
		model.needsUpdate = false
		# @set 'content', contentJSON
		# json = model.toJSON()

		if method is 'update' or method is 'create'
			options.data = JSON.stringify {chunk: model.toJSON()}
			# options.data = JSON.stringify {chunk: model.attributes}
			options.contentType = 'application/json'

		Backbone.sync method, model, options




	constructor: (attrs) ->
		console.log '______create', attrs
		if not attrs.id?
			@new = true
			attrs.id = @createNewLocalId()

		super attrs

		@dirty = false
		@needsUpdate = false
		@editing = false

		if attrs.content
			@componentContent = @getComponent().createNodeDataFromDescriptor(attrs)
		else
			@componentContent = {}

		@on "change", @onChange, @

		#@TODO - this seems crappy:
		# json = @toJSON()
		# @set 'savedJSON', JSON.stringify(@attributes)

	url: ->
		if @new? then return @urlRoot
		@urlRoot + '/' + encodeURIComponent(@get('id'))

	save: (attrs, options) ->
		console.clear()
		console.log 'SAVE TIME'
		if @new?
			@assignNewId()
			options.type = 'post'
			options.success = (->
				if @new then delete @new
				true
			).bind(@)

			console.log options

		super attrs, options

	assignNewId: ->
		@set 'id', @createNewLocalId()

	createNewLocalId: ->
		# "draft_id-user_id-#{createUUID()}"
		createUUID()

	onChange: (model, options) ->
		if model.get('index') isnt model.previous('index')
			@dirty = true
			@needsUpdate = true


	# update: ->
		# @set 'json', JSON.stringify(@toJSON())

	# shouldSave: ->
	# hasChanged: ->
		# savedJSON = @get('savedJSON')
		# json = @get('json')

		# savedJSON isnt json

	defaults: ->
		type: 'none'
		content: null
		contentType: 'json'
		derivedFrom: null
		index: null
		draftId: null

	addBefore: (sibling) ->
		@collection.add sibling, { at:@get('index') }

	addAfter: (sibling) ->
		@collection.add sibling, { at:@get('index') + 1 }

	# getIndex: ->
	# 	if not @collection? then return null
	# 	@collection.indexOf @

	prevSibling: ->
		index = @get('index')
		return null if @isFirst()

		@collection.at index - 1

	nextSibling: ->
		@collection.at @get('index') + 1

	isFirst: ->
		@get('index') is 0

	isLast: ->
		@get('index') is @collection.length - 1

	isBefore: (otherChunk) ->
		@get('index') < otherChunk.get('index')

	isAfter: (otherChunk) ->
		@get('index') > otherChunk.get('index')

	remove: ->
		@collection.remove @

	replaceWith: (newChunk) ->
		index = @get('index')
		collection = @collection

		collection.remove @
		collection.add newChunk, { at:index }

	getComponent: ->
		ComponentClassMap.getClassForType @get('type')

	callComponentFn: (fn, sel, content) ->
		# console.log 'callComponentFn', @, arguments, @get('type'), ComponentClassMap.getClassForType(@get('type')), ComponentClassMap.getClassForType(@get('type'))[fn]
		componentClass = @getComponent()
		commandHandler = componentClass.getCommandHandler @
		if not commandHandler?[fn] then return null
		commandHandler[fn].apply commandHandler, [sel, @].concat(content)

	getDomEl: ->
		document.body.querySelector ".component[data-id='#{@get('id')}']"

	clone: (cloneId = false) ->
		clone = new @constructor {
			type: @get('type')
		}
		clone.componentContent = @getComponent().cloneNodeData @componentContent

		if cloneId
			clone.set 'id', @get('id')

		clone


	markDirty: ->
		@dirty = true
		@needsUpdate = true
		# @set 'changed', Date.now()

	markForUpdate: ->
		@needsUpdate = true

	markUpdated: ->
		# console.log 'ccc mark updated', @get('index')
		@needsUpdate = false

	startEditing: ->
		@editing = true
		@markForUpdate()

	stopEditing: ->
		@editing = false
		@markForUpdate()

	# @TODO - this should really be called updateInteralAttributesAndAlsoReturnJSON
	toJSON: ->
		contentJSON = @getComponent().getDataDescriptor @

		# @set 'json', json

		json =
			type: @get 'type'
			content: contentJSON
			contentType: @get 'contentType'
			derivedFrom: @get 'derivedFrom'
			index: @get('index')
			id: @get 'id'
			draftId: @get 'draftId'

		#@TODO - seems crappy:
		# @set 'content', contentJSON

		# @set 'json', JSON.stringify(json)

		json

	#componentMethods

	revert: (selection) ->
		newChunk = Chunk.create()
		@replaceWith newChunk
		newChunk.selectEnd selection

		newChunk

	getCaretEdge: (selection) ->
		@callComponentFn 'getCaretEdge', selection

	canRemoveSibling: (selection, sibling) ->
		@callComponentFn 'canRemoveSibling', selection, [sibling]

	insertText: (selection, textToInsert, stylesToApply, stylesToRemove) ->
		@callComponentFn 'insertText', selection, [textToInsert, stylesToApply, stylesToRemove]

	deleteText: (selection, deleteForwards) ->
		@callComponentFn 'deleteText', selection, [deleteForwards]

	splitText: (selection, shiftKey) ->
		@callComponentFn 'splitText', selection, [shiftKey]

	deleteSelection: (selection) ->
		@callComponentFn 'deleteSelection', selection

	getCopyOfSelection: (selection) ->
		@callComponentFn 'getCopyOfSelection', selection

	styleSelection: (selection, styleType, styleData) ->
		@callComponentFn 'styleSelection', selection, [styleType, styleData]

	unstyleSelection: (selection, styleType, styleData) ->
		@callComponentFn 'unstyleSelection', selection, [styleType, styleData]

	getSelectionStyles: (selection) ->
		@callComponentFn 'getSelectionStyles', selection

	canMergeWith: (selection, otherChunk) ->
		console.log
		@callComponentFn 'canMergeWith', selection, [otherChunk]

	merge: (selection, digestedChunk) ->
		@callComponentFn 'merge', selection, [digestedChunk]

	indent: (selection, decreaseIndent) ->
		@callComponentFn 'indent', selection, [decreaseIndent]

	onTab: (selection, untab) ->
		@callComponentFn 'onTab', selection, [untab]

	acceptAbsorb: (selection, consumerChunk) ->
		@callComponentFn 'acceptAbsorb', selection, [consumerChunk]

	absorb: (selection, digestedChunk) ->
		@callComponentFn 'absorb', selection, [digestedChunk]

	transformSelection: (selection) ->
		@callComponentFn 'transformSelection', selection

	split: (selection) ->
		@callComponentFn 'split', selection

	saveSelection: (selection, position) ->
		@callComponentFn 'saveSelection', selection, [position]

	restoreSelection: (selection, type, savedSelData) ->
		@callComponentFn 'restoreSelection', selection, [type, savedSelData]

	saveDOMStateBeforeInput: (selection) ->
		@callComponentFn 'saveDOMStateBeforeInput', selection

	getDOMModificationAfterInput: (selection, domStateBefore) ->
		@callComponentFn 'getDOMModificationAfterInput', selection, [domStateBefore]

	applyDOMModification: (selection, domModifications) ->
		@callComponentFn 'applyDOMModification', selection, [domModifications]

	selectStart: (selection, asRange) ->
		@callComponentFn 'selectStart', selection, [asRange]

	selectEnd: (selection, asRange) ->
		@callComponentFn 'selectEnd', selection, [asRange]

	selectAll: (selection) ->
		@callComponentFn 'selectAll', selection

	getTextMenuCommands: (selection) ->
		@callComponentFn 'getTextMenuCommands', selection




# Chunk.createFromDescriptor = (descriptor) ->
# 	chunk = new Chunk {
# 		id: descriptor.id
# 		type: descriptor.type,
# 		content: ComponentClassMap.getClassForType(descriptor.type).createNodeDataFromDescriptor descriptor
# 		contentType: descriptor.contentType
# 		derivedFrom: descriptor.derivedFrom
# 		index: descriptor.index
# 		draftId: descriptor.draftId
# 	}

# 	#@TODO - this seems crappy:
# 	json = chunk.toJSON()
# 	json.index = descriptor.index
# 	chunk.set 'savedJSON', JSON.stringify(json)

Chunk.create = (typeOrClass = null, content = null) ->
	console.log '---------Chunk.create', arguments

	if not typeOrClass?
		componentClass = ComponentClassMap.getDefaultComponentClass()
		type = ComponentClassMap.getTypeOfClass componentClass
	else if typeof typeOrClass is 'string'
		componentClass = ComponentClassMap.getClassForType typeOrClass
		type = typeOrClass
	else
		componentClass = typeOrClass
		type = ComponentClassMap.getTypeOfClass typeOrClass

	content ?= componentClass.createNewNodeData()

	chunk = new Chunk {
		type: type
	}
	chunk.componentContent = content

	chunk

module.exports = Chunk